<!DOCTYPE html>
<html lang="en"><head><meta charset="utf-8"/><link href="../../../bootstrap/css/bootstrap.min.css" rel="stylesheet"/><link href="../../../bootstrap/css/bootstrap-responsive.min.css" rel="stylesheet"/><link href="../../../bootstrap/css/bootstrap-select.min.css" rel="stylesheet"/><link href="http://fonts.googleapis.com/css?family=Open+Sans:400,700,700italic,400italic" rel="stylesheet" type="text/css"/><link href="http://fonts.googleapis.com/css?family=Source+Sans+Pro:200,600,600italic,400" rel="stylesheet" type="text/css"/><link href="http://netdna.bootstrapcdn.com/font-awesome/4.1.0/css/font-awesome.css" rel="stylesheet" type="text/css"/><script src="../../../jquery-1.9.1.min.js"></script><script src="../../../bootstrap/js/bootstrap.min.js"></script><script src="../../../bootstrap/js/bootstrap-select.min.js"></script><link href="../../../styles.css" rel="stylesheet"/><script type="text/javascript">var dox = {rootPath: "../../../",platforms: ["js"]};</script><script type="text/javascript" src="../../..//nav.js"></script><script type="text/javascript" src="../../..//index.js"></script><link rel="icon" href="../../..//favicon.ico" type="image/x-icon"></link><title>js.node.domain.Domain</title></head><body><nav class="navbar dark navbar-static-top" role="navigation"><div class="container"><div class="navbar-header"><a class="brand" href="http://haxe.org/"><img src="http://haxe.org/img/haxe-logo-horizontal-on-dark.svg" width="107" height="21" alt="Haxe" onerror="this.src='http://haxe.org/img/haxe-logo-horizontal-on-dark.png'"/></a><span class="tagline">API Documentation</span><div class="pull-right"><a href="http://haxe.org/download/" target="_blank">Download</a> |<a href="http://haxe.org/manual/" target="_blank">Read the manual</a></div></div></div></nav><div class="container"><div class="row-fluid"><div class="span3"><div class="well sidebar-nav"><form class="form-search" id="searchForm"><div class="input-prepend input-block-level"><span class="add-on"><i class="icon-search"></i></span><input id="search" type="text" placeholder="Search" autocomplete="off"/></div></form></div><div class="well sidebar-nav"><div id="nav"></div></div></div><div class="span9"><div class="page-header"><span class="viewsource"><a href="https://github.com/HaxeFoundation/hxnodejs/blob/master/src/js/node/domain/Domain.hx">View source</a></span><h4><small>package js.node.domain</small></h4><h1><small>class</small>Domain</h1><h4><small>extends</small> <a class="type" title="All objects which emit events are instances of EventEmitter." href="../../../js/node/events/EventEmitter.html">EventEmitter</a>&lt;<a class="type" title="The Domain class encapsulates the functionality of routing errors and uncaught exceptions to the active Domain object." href="../../../js/node/domain/Domain.html">Domain</a>&gt;</h4></div><div class="body"><div class="doc doc-main"><div class="indent"><p>The Domain class encapsulates the functionality of routing errors
and uncaught exceptions to the active Domain object.</p></div></div><h3 class="section">Variables</h3><div class="fields"><div class="field "><a name="members"></a><h3><p><code><span class="label">read only</span><a href="#members"><span class="identifier">members</span></a>:<a class="type" title="An Array is a storage for values." href="../../../Array.html">Array</a>&lt;<a class="type" title="An abstract type allowing values to be either of T1 or T2 type." href="../../../haxe/extern/EitherType.html">EitherType</a>&lt;<a class="type" title="IEventEmitter interface is used as "any EventEmitter"." href="../../../js/node/events/IEventEmitter.html">IEventEmitter</a>, <a class="type" title="Base class for the opaque value returned by setTimeout and setInterval." href="../../../js/TimerObject.html">TimerObject</a>&gt;&gt;</code></p></h3><div class="doc"><p>An array of timers and event emitters that have been explicitly added to the domain.</p></div></div></div><h3 class="section">Methods</h3><div class="fields"><div class="field "><a name="add"></a><h3><p><code><a href="#add"><span class="identifier">add</span></a> (<span style="white-space:nowrap">emitter:<a class="type" title="IEventEmitter interface is used as "any EventEmitter"." href="../../../js/node/events/IEventEmitter.html">IEventEmitter</a></span>):<a class="type" title="The standard Void type." href="../../../Void.html">Void</a></code></p><p><code><a href="#add"><span class="identifier">add</span></a> (<span style="white-space:nowrap">emitter:<a class="type" title="Base class for the opaque value returned by setTimeout and setInterval." href="../../../js/TimerObject.html">TimerObject</a></span>):<a class="type" title="The standard Void type." href="../../../Void.html">Void</a></code></p></h3><div class="doc"><p>Explicitly adds an <code>emitter</code> to the domain.</p>
<p>If any event handlers called by the emitter throw an error, or if the emitter emits an error event,
it will be routed to the domain's error event, just like with implicit binding.</p>
<p>This also works with timers that are returned from <code>setInterval</code> and <code>setTimeout</code>.
If their callback function throws, it will be caught by the domain 'error' handler.</p>
<p>If the Timer or EventEmitter was already bound to a domain, it is removed from that one,
and bound to this one instead.</p></div></div><div class="field "><a name="bind"></a><h3><p><code><a href="#bind"><span class="identifier">bind</span></a>&lt;<span class="type">T</span>&gt; (<span style="white-space:nowrap">callback:<span class="type">T</span></span>):<span class="type">T</span></code></p></h3><div class="doc"><p>The returned function will be a wrapper around the supplied <code>callback</code> function.
When the returned function is called, any errors that are thrown will be routed to the domain's error event.</p></div></div><div class="field "><a name="dispose"></a><h3><p><code><a href="#dispose"><span class="identifier">dispose</span></a> ():<a class="type" title="The standard Void type." href="../../../Void.html">Void</a></code></p></h3><div class="doc"><p>The <code>dispose</code> method destroys a domain, and makes a best effort attempt
to clean up any and all IO that is associated with the domain.</p>
<p>Streams are aborted, ended, closed, and/or destroyed. Timers are cleared.
Explicitly bound callbacks are no longer called.</p>
<p>Any error events that are raised as a result of this are ignored.</p>
<p>The intention of calling <code>dispose</code> is generally to prevent cascading errors when a critical part of
the Domain context is found to be in an error state.</p>
<p>Once the domain is disposed the 'dispose' event will emit.</p>
<p>Note that IO might still be performed. However, to the highest degree possible, once a domain is disposed,
further errors from the emitters in that set will be ignored. So, even if some remaining actions are still
in flight, Node.js will not communicate further about them.</p></div></div><div class="field "><a name="enter"></a><h3><p><code><a href="#enter"><span class="identifier">enter</span></a> ():<a class="type" title="The standard Void type." href="../../../Void.html">Void</a></code></p></h3><div class="doc"><p>The <code>enter</code> method is plumbing used by the <code>run</code>, <code>bind</code>, and <code>intercept</code> methods to set the active domain.</p>
<p>It sets <code>domain.active</code> and <code>process.domain</code> to the domain, and implicitly pushes the domain onto
the domain stack managed by the domain module (see <code>exit</code> for details on the domain stack).</p>
<p>The call to <code>enter</code> delimits the beginning of a chain of asynchronous calls and I/O operations bound to a domain.</p>
<p>Calling <code>enter</code> changes only the active domain, and does not alter the domain itself.
Enter and exit can be called an arbitrary number of times on a single domain.</p>
<p>If the domain on which <code>enter</code> is called has been disposed, <code>enter</code> will return without setting the domain.</p></div></div><div class="field "><a name="exit"></a><h3><p><code><a href="#exit"><span class="identifier">exit</span></a> ():<a class="type" title="The standard Void type." href="../../../Void.html">Void</a></code></p></h3><div class="doc"><p>The <code>exit</code> method exits the current domain, popping it off the domain stack.</p>
<p>Any time execution is going to switch to the context of a different chain of asynchronous calls,
it's important to ensure that the current domain is exited. The call to <code>exit</code> delimits either the end of
or an interruption to the chain of asynchronous calls and I/O operations bound to a domain.</p>
<p>If there are multiple, nested domains bound to the current execution context,
<code>exit</code> will exit any domains nested within this domain.</p>
<p>Calling <code>exit</code> changes only the active domain, and does not alter the domain itself.
Enter and exit can be called an arbitrary number of times on a single domain.</p>
<p>If the domain on which <code>exit</code> is called has been disposed, <code>exit</code> will return without exiting the domain.</p></div></div><div class="field "><a name="intercept"></a><h3><p><code><a href="#intercept"><span class="identifier">intercept</span></a>&lt;<span class="type">T</span>&gt; (<span style="white-space:nowrap">callback:<span class="type">T</span></span>):<span class="type">T</span></code></p></h3><div class="doc"><p>This method is almost identical to <code>bind</code>. However, in addition to catching thrown errors, it will also
intercept <code><a href="../../../js/Error.html">Error</a></code> objects sent as the first argument to the function.</p>
<p>In this way, the common if (er != null) return callback(er); pattern
can be replaced with a single error handler in a single place.</p></div></div><div class="field "><a name="remove"></a><h3><p><code><a href="#remove"><span class="identifier">remove</span></a> (<span style="white-space:nowrap">emitter:<a class="type" title="IEventEmitter interface is used as "any EventEmitter"." href="../../../js/node/events/IEventEmitter.html">IEventEmitter</a></span>):<a class="type" title="The standard Void type." href="../../../Void.html">Void</a></code></p><p><code><a href="#remove"><span class="identifier">remove</span></a> (<span style="white-space:nowrap">emitter:<a class="type" title="Base class for the opaque value returned by setTimeout and setInterval." href="../../../js/TimerObject.html">TimerObject</a></span>):<a class="type" title="The standard Void type." href="../../../Void.html">Void</a></code></p></h3><div class="doc"><p>The opposite of <code>add</code>. Removes domain handling from the specified emitter.</p></div></div><div class="field "><a name="run"></a><h3><p><code><a href="#run"><span class="identifier">run</span></a> (<span style="white-space:nowrap">fn:<a class="type" title="The standard Void type." href="../../../Void.html">Void</a>&nbsp;&#8209;&gt;&nbsp;<a class="type" title="The standard Void type." href="../../../Void.html">Void</a></span>):<a class="type" title="The standard Void type." href="../../../Void.html">Void</a></code></p></h3><div class="doc"><p>Run the supplied function in the context of the domain, implicitly binding all event emitters, timers,
and lowlevel requests that are created in that context.</p>
<p>This is the most basic way to use a domain.</p></div></div></div></div></div></div></div><footer class="section dark site-footer"><div class="container"><div class="copyright"><p>&copy;2015&nbsp;<a href="http://haxe.org/foundation/" title="Haxe Foundation Website" class="hf-link">Haxe Foundation</a> |&nbsp;<a href="https://github.com/HaxeFoundation/haxe" title="Haxe on Github">Contribute to Haxe</a></p></div></div></footer><script src="https://google-code-prettify.googlecode.com/svn/loader/run_prettify.js"></script></body></html>